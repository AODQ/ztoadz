#version 460
#extension GL_EXT_shader_image_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0, r64ui) uniform u64image2D visibilitySurfaceImage;

layout (set = 0, binding = 1) buffer TriangleVertexAssembly {
  vec4 inputOrigins[];
};

layout (set = 0, binding = 2) buffer TriangleVertexAssemblyMetadata {
  uint32_t numTriangles;
};

vec3 computeBarycentricUv(
  vec2 b0, vec2 b1, vec2 b2,
  vec2 ori
) {
  vec2
    v0 = b1  - b0,
    v1 = b2  - b0,
    v2 = ori - b0
  ;

  float
    d00 = dot(v0, v0),
    d01 = dot(v0, v1),
    d11 = dot(v1, v1),
    d20 = dot(v2, v0),
    d21 = dot(v2, v1)
  ;

  float denom = d00*d11 - d01*d01;
  float v = (d11*d20 - d01*d21) / denom;
  float w = (d00*d21 - d01*d20) / denom;
  return vec3(1.0f-v-w, v, w);
}

float rasterizeTriangle(
  const vec2 uv,
  const uint triangleId
) {
  vec4 origin0 = inputOrigins[triangleId + 0];
  vec4 origin1 = inputOrigins[triangleId + 1];
  vec4 origin2 = inputOrigins[triangleId + 2];

  mat3 baseVertices = mat3(
    origin0.x, origin1.x, origin2.x,
    origin0.y, origin1.y, origin2.y,
    origin0.z, origin1.z, origin2.z
  );

  // backface culling, need to do from options
  /* if (determinant(baseVertices) <= 0.0f) { */
  /*   return 0.0f; */
  /* } */

  baseVertices = inverse(baseVertices);

  vec3 E0 = baseVertices[0];
  vec3 E1 = baseVertices[1];
  vec3 E2 = baseVertices[2];

  vec3 uvw = vec3(uv, 1.0f);

  vec3 edge = vec3(dot(E0, uvw), dot(E1, uvw), dot(E2, uvw));

  if (edge.x < 0.0f || edge.y < 0.0f || edge.z < 0.0f) {
    return 0.0f;
  }

  // interpolate 1/w at fragment
  vec3 perspectiveCorrection = baseVertices * vec3(1.0f);
  float oneOverW = dot(perspectiveCorrection, uvw);

  // w = 1/(1/w)
  float w = 1.0f/oneOverW;

  vec3 zVec = baseVertices * vec3(origin0.z, origin1.z, origin2.z);
  float zOverW = dot(zVec, uvw);
  float z = zOverW * w;
  return 1.0f/z;

  /* // interpolate Z */
  /* float zOverW = */ 
}

uvec4 toSrgb(const vec4 inp) {
  return uvec4(inp * vec4(255.0f));
}

void main() {
  const ivec2 imageColorDim = imageSize(visibilitySurfaceImage);
  const ivec3 dispatchId = ivec3(gl_GlobalInvocationID.xyz);

  const uint32_t triangleIt = dispatchId.x;

  vec4 v0 = inputOrigins[triangleIt*3+0];
  vec4 v1 = inputOrigins[triangleIt*3+1];
  vec4 v2 = inputOrigins[triangleIt*3+2];

  vec2 t0 = v0.xy/v0.z;
  vec2 t1 = v1.xy/v1.z;
  vec2 t2 = v2.xy/v2.z;

  /* t0 = (t0 * vec2(2.0f)) - vec2(1.0f); */
  /* t1 = (t1 * vec2(2.0f)) - vec2(1.0f); */
  /* t2 = (t2 * vec2(2.0f)) - vec2(1.0f); */

  ivec2 minBounds = ivec2(0);
  ivec2 maxBounds = ivec2(imageColorDim);

  /* minBounds.x = int(min(t0.x, min(t1.x, t2.x))*imageColorDim.x); */
  /* maxBounds.x = int(max(t0.x, max(t1.x, t2.x))*imageColorDim.x); */
  /* minBounds.x = 0; */
  /* maxBounds.x = 250; */

  minBounds = ivec2(min(t0, min(t1, t2))*imageColorDim.xy);
  maxBounds = ivec2(max(t0, max(t1, t2))*imageColorDim.xy);
  /* minBounds = ivec2(0); */
  /* maxBounds = ivec2(250); */

  for (int itX = minBounds.x; itX < maxBounds.x; ++ itX)
  for (int itY = minBounds.y; itY < maxBounds.y; ++ itY) {
    vec2 uvcoord = vec2(itX, itY) / vec2(imageColorDim);
    /* uvcoord = (uvcoord * vec2(2.0f)) - vec2(1.0f); */
    float interDepth = rasterizeTriangle(uvcoord, triangleIt*3);
    if (interDepth > 0.0f && interDepth <= 1.0f) {
      uint32_t depthU32 = floatBitsToUint(interDepth);
      uint32_t triangleIdU32 = uint32_t(triangleIt);
      uint64_t triangleStore = triangleIdU32 | (uint64_t(depthU32) << 32);
      imageAtomicMax(visibilitySurfaceImage, ivec2(itX, itY), triangleStore);
    }
  }
}
