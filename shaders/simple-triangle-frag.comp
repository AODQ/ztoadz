#version 460
#extension GL_EXT_shader_image_int64 : require
#extension GL_EXT_shader_explicit_arithmetic_types : require

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

layout (set = 0, binding = 0, r64ui) uniform u64image2D visibilitySurfaceImage;

layout (set = 0, binding = 1) buffer TriangleVertexAssembly {
  vec4 inputOrigins[];
};

layout (set = 0, binding = 2) buffer TriangleVertexAssemblyMetadata {
  uint32_t numTriangles;
};

struct TriangleInfo {
  vec4 screenV0;
  vec4 screenV1;
  vec4 screenV2;

  /* vec2 ndcV0; */
  /* vec2 ndcV1; */
  /* vec2 ndcV2; */
};

TriangleInfo GatherTriangleInfo(
  const uint32_t triangleId,
  const ivec2 viewportDim
) {
  vec4 v0 = inputOrigins[triangleId*3+0];
  vec4 v1 = inputOrigins[triangleId*3+1];
  vec4 v2 = inputOrigins[triangleId*3+2];

  TriangleInfo triangle;

  triangle.screenV0 = v0;
  triangle.screenV1 = v1;
  triangle.screenV2 = v2;

  #define toScreen(v) v.xy = (viewportDim * v.xy);

  toScreen(triangle.screenV0);
  toScreen(triangle.screenV1);
  toScreen(triangle.screenV2);

  #undef toScreen

  return triangle;
}

float rasterizeTriangle(const TriangleInfo tri, const vec2 uv) {
  const mat3 tris = (
    inverse(mat3(tri.screenV0.xyz, tri.screenV1.xyz, tri.screenV2.xyz))
  );
  const vec3 uvw = vec3(uv, 1.0f);

  // interpolate barycentric coordinate of screen
  vec3 bcScreen = tris * uvw;

  if (!(bcScreen.x >= 0.0f && bcScreen.y >= 0.0f && bcScreen.z >= 0.0f))
    return 0.0f;

  // normalize
  bcScreen /= dot(bcScreen, vec3(1.0f));

  // apply barycentric coords to clip space to apply perspective projection
  vec3 bcClip = bcScreen / vec3(tri.screenV0.w, tri.screenV1.w, tri.screenV2.w);

  return 1.0f/dot(bcClip, vec3(tri.screenV0.z, tri.screenV1.z, tri.screenV2.z));
}

uvec4 toSrgb(const vec4 inp) {
  return uvec4(inp * vec4(255.0f));
}

void main() {
  const ivec2 viewportDim = imageSize(visibilitySurfaceImage);
  const ivec3 dispatchId = ivec3(gl_GlobalInvocationID.xyz);

  const uint32_t triangleId = dispatchId.x;

  if (triangleId >= numTriangles) {
    return;
  }

  TriangleInfo tri = GatherTriangleInfo(triangleId, viewportDim);

  const vec2 v0 = tri.screenV0.xy / tri.screenV0.z;
  const vec2 v1 = tri.screenV1.xy / tri.screenV1.z;
  const vec2 v2 = tri.screenV2.xy / tri.screenV2.z;

  const ivec2 minBounds = (
    ivec2(
      max(
        vec2(-viewportDim/2.0f-1.0f),
        min(v0.xy, min(v1.xy, v2.xy))-vec2(0.5f)
      )
    )
  );

  const ivec2 maxBounds = (
    ivec2(
      min(
        vec2(+viewportDim/2.0f+1.0f),
        max(v0.xy, max(v1.xy, v2.xy))+vec2(0.5f)
      )
    )
  );

  for (int itX = minBounds.x; itX < maxBounds.x; ++ itX)
  for (int itY = minBounds.y; itY < maxBounds.y; ++ itY) {
    vec2 uvcoord = vec2(itX, itY) + vec2(0.5f);
    float interDepth = rasterizeTriangle(tri, uvcoord);
    uint32_t triangleIdU32 = uint32_t(triangleId);
    if (interDepth > 0.0f && interDepth <= 1.0f) {
      uint32_t depthU32 = floatBitsToUint(interDepth);
      uint64_t triangleStore = triangleIdU32 | (uint64_t(depthU32) << 32);
      imageAtomicMax(
        visibilitySurfaceImage,
        viewportDim/2+ivec2(itX, itY),
        triangleStore
      );
    }
  }
}
